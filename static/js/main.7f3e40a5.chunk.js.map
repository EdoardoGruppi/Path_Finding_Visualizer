{"version":3,"sources":["PathFindingVisualizer/Node/Node.jsx","Algorithms/Utils.js","Algorithms/Dijkstra.js","Algorithms/BreadthFirst.js","Algorithms/DepthFirst.js","Algorithms/Greedy.js","Algorithms/AStar.js","PathFindingVisualizer/PathFindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","col","isFinish","isStart","weight","isWall","side","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","style","height","width","className","getUnvisitedNeighbors","node","grid","neighbors","length","push","filter","neighbor","isVisited","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","sortNodesByDistanceToEnd","heuristic","sortNodesByTotalDistance","getAllNodes","nodes","weightedHeuristic","additionalXChange","sumHorizontalWeights","otherXChange","additionalYChange","sumVerticalWeights","otherYChange","additionalChange","otherChange","weightedManhattanDistance","col1","col2","sum","currentCol","row1","row2","currentRow","dijkstra","startNode","finishNode","visitedNodesInOrder","closestNode","shift","Infinity","updateUnvisitedNeighbors","unvisitedNeighbors","previousNode","breadthFirst","queueNodesToVisit","depthFirst","unshift","greedy","distanceToEnd","aStar","PathFindingVisualizer","useState","rows","setRows","Math","round","window","innerWidth","cols","setCols","speed","setSpeed","setGrid","mouseIsPressed","setMouseIsPressed","randomIntFromInterval","startNodeRow","setStartNodeRow","startNodeCol","setStartNodeCol","finishNodeRow","setFinishNodeRow","finishNodeCol","setFinishNodeCol","itemPressed","setItemPressed","keyPressed","setKeyPressed","description","setDescription","timeIDs","useRef","running","algo","descriptions","functions","useEffect","new_grid","getInitialGrid","document","addEventListener","handleKeyDown","createNode","e","includes","key","clearGrid","resetNode","getElementById","clearPath","moveStartNode","newStartNode","newNode","moveFinishNode","newFinishNode","animateShortestPath","nodesInShortestPathOrder","i","current","setTimeout","extraClass","changeButtonText","visualizeAlgorithm","algorithm","animateAlgorithm","currentNode","getNodesInShortestPathOrder","stopExecution","clearTimeout","innerText","display","type","min","step","defaultValue","max","onChange","value","updateGridSize","onClick","map","rowIdx","nodeIdx","newGrid","getNewGridWithWeightToggled","getNewGridWithWallToggled","handleMouseDown","handleMouseEnter","keepWall","keepWeights","floor","random","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.7f3e40a5.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\n\r\nexport default function Node(props) {\r\n  const {\r\n    col,\r\n    isFinish,\r\n    isStart,\r\n    weight,\r\n    isWall,\r\n    side,\r\n    onMouseDown,\r\n    onMouseEnter,\r\n    onMouseUp,\r\n    row,\r\n  } = props;\r\n\r\n  const extraClassName = isFinish\r\n    ? \"node-finish\"\r\n    : isStart\r\n    ? \"node-start\"\r\n    : isWall\r\n    ? \"node-wall\"\r\n    : weight > 1\r\n    ? \"node-weight\"\r\n    : \"\";\r\n\r\n  return (\r\n    <div\r\n      id={`node-${row}-${col}`}\r\n      style={{\r\n        height: `${side}px`,\r\n        width: `${side}px`,\r\n      }}\r\n      className={`node ${extraClassName}`}\r\n      onMouseDown={() => onMouseDown(row, col)}\r\n      onMouseEnter={() => onMouseEnter(row, col)}\r\n      onMouseUp={() => onMouseUp()}\r\n    ></div>\r\n  );\r\n}\r\n","export function getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  // Get the neighbour at the right\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  // Get the neighbour at the top\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  // Get the neighbour at the bottom\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  // Get the neighbour at the left\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  // Return only the neighbours that have not been already visited\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// It must be called only AFTER the pathfinding algorithm.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    // Add the current node and pass to the previous node which is pointed by the current node\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function sortNodesByDistance(unvisitedNodes) {\r\n  // The sorting occurs following an ascending order\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function sortNodesByDistanceToEnd(unvisitedNodes) {\r\n  // The sorting occurs following an ascending order\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.heuristic - nodeB.heuristic);\r\n}\r\n\r\nexport function sortNodesByTotalDistance(unvisitedNodes) {\r\n  // The sorting occurs following an ascending order\r\n  unvisitedNodes.sort(\r\n    (nodeA, nodeB) =>\r\n      nodeA.heuristic + nodeA.distance - (nodeB.heuristic + nodeB.distance)\r\n  );\r\n}\r\n\r\nexport function getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function heuristic(nodeA, nodeB) {\r\n  // Heursitic function computed with the manhattan distance\r\n  return manhattanDistance(nodeA, nodeB);\r\n}\r\n\r\nfunction manhattanDistance(nodeA, nodeB) {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\nexport function weightedHeuristic(grid, nodeA, nodeB) {\r\n  // Heursitic function computed with a weighted version of the manhattan distance\r\n  return weightedManhattanDistance(grid, nodeA, nodeB);\r\n}\r\n\r\nfunction weightedManhattanDistance(grid, nodeA, nodeB) {\r\n  // To get the weighted manhattan distance, this function considers two distinct paths.\r\n  // The first pass through x1 to x2 and then from y1 to y2. The second viceversa.\r\n  const additionalXChange = sumHorizontalWeights(\r\n    grid,\r\n    nodeA.row,\r\n    nodeA.col,\r\n    nodeB.col\r\n  );\r\n  const otherXChange = sumHorizontalWeights(\r\n    grid,\r\n    nodeB.row,\r\n    nodeA.col,\r\n    nodeB.col\r\n  );\r\n  const additionalYChange = sumVerticalWeights(\r\n    grid,\r\n    nodeB.col,\r\n    nodeA.row,\r\n    nodeB.row\r\n  );\r\n  const otherYChange = sumVerticalWeights(\r\n    grid,\r\n    nodeA.col,\r\n    nodeA.row,\r\n    nodeB.row\r\n  );\r\n  const additionalChange = additionalXChange + additionalYChange;\r\n  const otherChange = otherXChange + otherYChange;\r\n  // Compare the two paths to return the one that is shortest\r\n  if (additionalChange < otherChange) return additionalChange;\r\n  else return otherChange;\r\n}\r\n\r\nfunction sumHorizontalWeights(grid, row, col1, col2) {\r\n  let sum = 0;\r\n  // Swap y1 and y2 if y1 > y2\r\n  if (col1 > col2) [col1, col2] = [col2, col1];\r\n  // Sum all the weights of the nodes in the path\r\n  for (let currentCol = col1; currentCol <= col2; currentCol++) {\r\n    const currentNode = grid[row][currentCol];\r\n    sum += currentNode.weight;\r\n  }\r\n  return sum;\r\n}\r\n\r\nfunction sumVerticalWeights(grid, col, row1, row2) {\r\n  let sum = 0;\r\n  // Swap x1 and x2 if x1 > x2. The '+1' and '-1' below are inserted to avoid\r\n  // considering twice the same node in the corner.\r\n  if (row1 > row2) [row1, row2] = [row2 + 1, row1];\r\n  else row2 = row2 - 1;\r\n  for (let currentRow = row1; currentRow <= row2; currentRow++) {\r\n    const currentNode = grid[currentRow][col];\r\n    sum += currentNode.weight;\r\n  }\r\n  return sum;\r\n}\r\n","import {\r\n  getUnvisitedNeighbors,\r\n  getAllNodes,\r\n  sortNodesByDistance,\r\n} from \"./Utils\";\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  // Except for the starting node the distance == Infinity\r\n  startNode.distance = 0;\r\n  // At the beginning all the nodes are unvisited\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  // While there are still unvisited nodes\r\n  while (unvisitedNodes.length) {\r\n    // Sort nodes by distance\r\n    sortNodesByDistance(unvisitedNodes);\r\n    // Take from the array the first element, i.e. the nearest\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity, the game is trapped and must be stopped\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    // Otherwise the node is traversed by the algorithm\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    // Update distances\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // The distance of the neighbours is equal to that of the node plus one\r\n    // So far, the algorithm version does not involve weights\r\n    // child distance = dist[currentNode from source] + distance [from currentNode to child node].\r\n    neighbor.distance = node.distance + neighbor.weight;\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n","import { getUnvisitedNeighbors } from \"./Utils\";\r\n\r\nexport function breadthFirst(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queueNodesToVisit = [];\r\n  startNode.isVisited = true;\r\n  queueNodesToVisit.push(startNode);\r\n  // While there are still unvisited nodes\r\n  while (queueNodesToVisit.length) {\r\n    const closestNode = queueNodesToVisit.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // Otherwise the node is traversed by the algorithm\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    queueNodesToVisit.push(...updateUnvisitedNeighbors(closestNode, grid));\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n    neighbor.isVisited = true;\r\n  }\r\n  return unvisitedNeighbors;\r\n}\r\n","import { getUnvisitedNeighbors } from \"./Utils\";\r\n\r\nexport function depthFirst(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queueNodesToVisit = [];\r\n  startNode.isVisited = true;\r\n  queueNodesToVisit.push(startNode);\r\n  // While there are still unvisited nodes\r\n  while (queueNodesToVisit.length) {\r\n    const closestNode = queueNodesToVisit.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // Otherwise the node is traversed by the algorithm\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    queueNodesToVisit.unshift(...updateUnvisitedNeighbors(closestNode, grid));\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n  }\r\n  return unvisitedNeighbors;\r\n}\r\n","import {\r\n  getUnvisitedNeighbors,\r\n  weightedHeuristic,\r\n  getAllNodes,\r\n  sortNodesByDistanceToEnd,\r\n} from \"./Utils\";\r\n\r\nexport function greedy(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  // Except for the starting node the distance == Infinity\r\n  startNode.heuristic = 0;\r\n  // At the beginning all the nodes are unvisited\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  // While there are still unvisited nodes\r\n  while (unvisitedNodes.length) {\r\n    // Sort nodes by distance\r\n    sortNodesByDistanceToEnd(unvisitedNodes);\r\n    // Take from the array the first element, i.e. the nearest\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity, the game is trapped and must be stopped\r\n    if (closestNode.heuristic === Infinity) return visitedNodesInOrder;\r\n    // Otherwise the node is traversed by the algorithm\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    // Update distances\r\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // The heuristic here used to compute the distance from the current node to the end is formulated\r\n    // as the sum between the weighted manhattan distance and the node weight.\r\n    const distanceToEnd =\r\n      neighbor.weight + weightedHeuristic(grid, neighbor, finishNode);\r\n    if (neighbor.heuristic > distanceToEnd) neighbor.heuristic = distanceToEnd;\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n","import {\r\n  getUnvisitedNeighbors,\r\n  weightedHeuristic,\r\n  getAllNodes,\r\n  sortNodesByTotalDistance,\r\n} from \"./Utils\";\r\n\r\nexport function aStar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  // Except for the starting node the distance == Infinity\r\n  startNode.distance = 0;\r\n  startNode.heuristic = weightedHeuristic(grid, startNode, finishNode);\r\n  // At the beginning all the nodes are unvisited\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  // While there are still unvisited nodes\r\n  while (unvisitedNodes.length) {\r\n    // Sort nodes by distance\r\n    sortNodesByTotalDistance(unvisitedNodes);\r\n    // Take from the array the first element, i.e. the nearest\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity, the game is trapped and must be stopped\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    // Otherwise the node is traversed by the algorithm\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    // Update distances\r\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // The distance is computed adding the node weight to the manhattan distance\r\n    const distance = node.distance + neighbor.weight;\r\n    if (neighbor.distance > distance) neighbor.distance = distance;\r\n    // On the other hand the heuristic is calculated as a weighted variant of the weighted manhattan distance\r\n    neighbor.heuristic = 1.5 * weightedHeuristic(grid, neighbor, finishNode);\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n","import { useState, useEffect, useRef } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathFindingVisualizer.css\";\r\nimport { dijkstra } from \"../Algorithms/Dijkstra\";\r\nimport { breadthFirst } from \"../Algorithms/BreadthFirst\";\r\nimport { depthFirst } from \"../Algorithms/DepthFirst\";\r\nimport { greedy } from \"../Algorithms/Greedy\";\r\nimport { aStar } from \"../Algorithms/AStar\";\r\nimport { getNodesInShortestPathOrder } from \"../Algorithms/Utils\";\r\n\r\nexport default function PathFindingVisualizer() {\r\n    const [rows, setRows] = useState(10);\r\n    const [cols, setCols] = useState(Math.round((0.8*window.innerWidth)/50));\r\n    const [speed, setSpeed] = useState(10);\r\n    const [grid, setGrid] = useState([]);\r\n    // Element that follows the mouse events\r\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n    // Rows and Cols of the starting and final node\r\n    const [startNodeRow, setStartNodeRow] = useState(randomIntFromInterval(0, rows - 1));\r\n    const [startNodeCol, setStartNodeCol] = useState(randomIntFromInterval(0, cols / 2));\r\n    const [finishNodeRow, setFinishNodeRow] = useState(randomIntFromInterval(0, rows - 1));\r\n    const [finishNodeCol, setFinishNodeCol] = useState(randomIntFromInterval(cols / 2 + 1, cols - 1));\r\n    // Element to keep track whether a special node is pressed\r\n    const [itemPressed, setItemPressed] = useState(null);\r\n    // Element to know which key has been pressed\r\n    const [keyPressed, setKeyPressed] = useState(\"r\");\r\n    const [description, setDescription] = useState(\"Press W to insert weights and R to get back to walls.\");\r\n    // Keep track of the animation ops\r\n    let timeIDs = useRef([]);\r\n    let running = useRef(false);\r\n    let algo = useRef(-1);\r\n    const descriptions = [\"Press W to insert weights and R to get back to walls.\",\r\n                          \"Dijkstra is a weighted algorithm that guarantees the shortest possible path.\",\r\n                          \"BreadthFirst is an unweighted algorithm that guarantees the shortest possible path.\",\r\n                          \"DepthFirst is an unweighted algorithm that does not guarantee the shortest path.\",\r\n                          \"Greedy is a weighted algorithm that does not guarantee the shortest path.\",\r\n                          \"A* is a weighted algorithm that usually guarantees the shortest possible path.\"]; \r\n    const functions = [dijkstra, breadthFirst, depthFirst, greedy, aStar];\r\n    \r\n    useEffect(()=>{\r\n      const new_grid = getInitialGrid();\r\n      // Add a listener to react when a key is pressed\r\n      document.addEventListener(\"keydown\", handleKeyDown);\r\n      setGrid(new_grid);\r\n      // eslint-disable-next-line\r\n    }, [])\r\n\r\n    useEffect(()=>{\r\n      setGrid(getInitialGrid());\r\n      // eslint-disable-next-line\r\n    }, [rows])\r\n\r\n    const createNode = (col, row) => {\r\n      // Create a node with the default values\r\n      return {\r\n        col,\r\n        row,\r\n        isStart:\r\n          row === startNodeRow && col === startNodeCol,\r\n        isFinish:\r\n          row === finishNodeRow && col === finishNodeCol,\r\n        // Distance from the starting Node\r\n        distance: Infinity,\r\n        // Distance from the end node computed with heuristic\r\n        heuristic: Infinity,\r\n        weight: 1,\r\n        isVisited: false,\r\n        isWall: false,\r\n        previousNode: null,\r\n      };\r\n    }\r\n\r\n    const getInitialGrid = () => {\r\n      // Create a 2d Array of new nodes\r\n      const new_grid = [];\r\n      for (let row = 0; row < rows; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < cols; col++) {\r\n          currentRow.push(createNode(col, row));\r\n        }\r\n        new_grid.push(currentRow);\r\n      }\r\n      return new_grid;\r\n    }\r\n\r\n    const handleKeyDown = (e) => {\r\n      // Keep track of the jey pressed only if it corresponds to r or w\r\n      if (\"rw\".includes(e.key)) setKeyPressed(e.key);\r\n    }\r\n\r\n    const handleMouseUp = () => {\r\n      // Function called when the mouse is pressed up\r\n      setMouseIsPressed(false);\r\n      setItemPressed(null);\r\n    }\r\n    \r\n    const clearGrid = () => {\r\n      for (let row of grid) {\r\n        for (let node of row) {\r\n          // Reset the features of the node\r\n          resetNode(node);\r\n          const extraClassName = node.isFinish\r\n            ? \"node-finish\"\r\n            : node.isStart\r\n            ? \"node-start\"\r\n            : node.isWall\r\n            ? \"node-wall\"\r\n            : \"\";\r\n          // Update the node visualization\r\n          document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          ).className = `node ${extraClassName}`;\r\n        }\r\n      }\r\n    }\r\n\r\n    const updateGridSize = () => {\r\n      // Clear the entire grid\r\n      clearGrid();\r\n      // Get the new row values selected through the slider\r\n      const rows = document.getElementById(\"n_rows\").value;\r\n      const cols = Math.round((0.8*window.innerWidth)/50);\r\n      setStartNodeRow(randomIntFromInterval(0, rows - 1));\r\n      setStartNodeCol(randomIntFromInterval(0, cols / 2));\r\n      setFinishNodeRow(randomIntFromInterval(0, rows - 1));\r\n      setFinishNodeCol(randomIntFromInterval(cols / 2 + 1, cols - 1));\r\n      setCols(cols);\r\n      setRows(rows);\r\n    }\r\n\r\n    const clearPath = () => {\r\n      for (let row of grid) {\r\n        for (let node of row) {\r\n          // Reset each node but retain the wall and the weighted cells\r\n          resetNode(node, true, true);\r\n          const extraClassName = node.isFinish\r\n            ? \"node-finish\"\r\n            : node.isStart\r\n            ? \"node-start\"\r\n            : node.isWall\r\n            ? \"node-wall\"\r\n            : node.weight > 1\r\n            ? \"node-weight\"\r\n            : \"\";\r\n          // Update the node visualization\r\n          document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          ).className = `node ${extraClassName}`;\r\n        }\r\n      }\r\n    }\r\n\r\n    const moveStartNode = (grid, row, col) => {\r\n      const previousStartNode = grid[startNodeRow][startNodeCol];\r\n      previousStartNode.isStart = false;\r\n      const newStartNode = grid[row][col];\r\n      const newNode = {\r\n        ...newStartNode,\r\n        isStart: true,\r\n      };\r\n      grid[row][col] = newNode;\r\n      setStartNodeRow(row);\r\n      setStartNodeCol(col);\r\n      return grid;\r\n    }\r\n\r\n    const handleMouseDown = (row, col) => {\r\n      // Function called when the mouse is pressed down\r\n      const node = grid[row][col];\r\n      let itemPressed = null;\r\n      let newGrid = [];\r\n      if (node.isStart) {\r\n        newGrid = moveStartNode(grid, row, col);\r\n        itemPressed = \"startNode\";\r\n      } else if (node.isFinish) {\r\n        newGrid = moveFinishNode(grid, row, col);\r\n        itemPressed = \"finishNode\";\r\n      } else if (keyPressed === \"w\") {\r\n        newGrid = getNewGridWithWeightToggled(grid, row, col);\r\n      } else {\r\n        newGrid = getNewGridWithWallToggled(grid, row, col);\r\n      }\r\n      setGrid(newGrid);\r\n      setMouseIsPressed(true);\r\n      setItemPressed(itemPressed);\r\n    }\r\n  \r\n    const handleMouseEnter = (row, col) => {\r\n      // Change the nodes wall status if the mouse is moved after being pressed down\r\n      if (!mouseIsPressed) return;\r\n      let newGrid = [];\r\n      if (itemPressed === \"startNode\") {\r\n        newGrid = moveStartNode(grid, row, col);\r\n      } else if (itemPressed === \"finishNode\") {\r\n        newGrid = moveFinishNode(grid, row, col);\r\n      } else if (keyPressed === \"w\") {\r\n        newGrid = getNewGridWithWeightToggled(grid, row, col);\r\n      } else {\r\n        newGrid = getNewGridWithWallToggled(grid, row, col);\r\n      }\r\n      setGrid(newGrid);\r\n    }\r\n  \r\n    const moveFinishNode = (grid, row, col) => {\r\n      const previousFinishNode = grid[finishNodeRow][finishNodeCol];\r\n      previousFinishNode.isFinish = false;\r\n      const newFinishNode = grid[row][col];\r\n      const newNode = {\r\n        ...newFinishNode,\r\n        isFinish: true,\r\n      };\r\n      grid[row][col] = newNode;\r\n      setFinishNodeRow(row);\r\n      setFinishNodeCol(col);\r\n      return grid;\r\n    }\r\n  \r\n    const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n      // For each visited node\r\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n        // Only if it is the last node start the final animation\r\n        if (i === visitedNodesInOrder.length) {\r\n          timeIDs.current.push(setTimeout(() => {\r\n            animateShortestPath(nodesInShortestPathOrder);\r\n          }, speed * i));\r\n          return;\r\n        } else {\r\n          timeIDs.current.push(setTimeout(() => {\r\n            const node = visitedNodesInOrder[i];\r\n            let extraClass = \"\";\r\n            if (node.isStart) extraClass = \"start-\";\r\n            else if (node.isFinish) extraClass = \"finish-\";\r\n            else if (node.weight > 1) extraClass = \"weight-\";\r\n            // Animate the node according to its characteristics\r\n            document.getElementById(\r\n              `node-${node.row}-${node.col}`\r\n            ).className = `node ${extraClass}node-visited`;\r\n          }, speed * i));\r\n        }\r\n      }\r\n    }\r\n  \r\n    const animateShortestPath = (nodesInShortestPathOrder) => {\r\n      // Animation showing the shortest path\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        timeIDs.current.push(setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          let extraClass = \"\";\r\n          if (node.isStart) extraClass = \"start-\";\r\n          else if (node.isFinish) extraClass = \"finish-\";\r\n          else if (node.weight > 1) extraClass = \"weight-\";\r\n          // Animate the node according to its characteristics\r\n          document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          ).className = `node ${extraClass}node-shortest-path`;\r\n        }, speed * 5 * i));\r\n      }\r\n      timeIDs.current.push(setTimeout(()=>{\r\n        running.current = false;\r\n        changeButtonText();\r\n      }, nodesInShortestPathOrder.length * speed * 5))\r\n    }\r\n  \r\n    const visualizeAlgorithm = (algorithm) => {\r\n      // Update algorithm description\r\n      setDescription(descriptions[algorithm]); \r\n      // Clean the board from the previous path\r\n      clearPath();\r\n      // Set up the starting and final nodes\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      // Get the visited nodes in order\r\n      const visitedNodesInOrder = functions[algorithm-1](grid, startNode, finishNode);\r\n      // Get the nodes, belonging to the shortest path and visisted in order\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    // Stop the execution of the animation\r\n    const stopExecution = () => {\r\n      running.current = false;\r\n      changeButtonText();\r\n      for (let i=0; i<timeIDs.current.length; i++){\r\n        clearTimeout(timeIDs.current[i]);\r\n      }\r\n      timeIDs.current = [];\r\n    }\r\n\r\n    const changeButtonText = () => {\r\n      const btn = document.getElementById(\"run_btn\");\r\n      btn.innerText = running.current ? 'STOP' : 'RUN';\r\n    }\r\n\r\n    const playButtonLogic = () => {\r\n      if (running.current){ \r\n        stopExecution(); \r\n        clearPath();\r\n      } else {\r\n        if (algo.current>0) {\r\n          running.current = true;\r\n          changeButtonText();\r\n          visualizeAlgorithm(algo.current);\r\n        }\r\n      }\r\n    }\r\n\r\n    return (\r\n      <>\r\n        <div className=\"header\">\r\n          <div style={{ display: \"inline-block\" }}>\r\n            <span className=\"rangeValue\">SPEED: {speed}</span>\r\n            <input\r\n              className=\"range\"\r\n              id=\"speed\"\r\n              type=\"range\"\r\n              min=\"1\"\r\n              step=\"1\"\r\n              defaultValue=\"10\"\r\n              max=\"1000\"\r\n              onChange={() => setSpeed(document.getElementById(\"speed\").value)}\r\n            ></input>\r\n          </div>\r\n          <div style={{ display: \"inline-block\" }}>\r\n            <span className=\"rangeValue\">ROWS: {rows}</span>\r\n            <input\r\n              className=\"range\"\r\n              id=\"n_rows\"\r\n              type=\"range\"\r\n              min=\"1\"\r\n              step=\"1\"\r\n              defaultValue=\"10\"\r\n              max=\"25\"\r\n              onChange={() => {stopExecution(); updateGridSize()}}\r\n            ></input>\r\n          </div>\r\n          <button\r\n            className=\"button_slide slide_down\"\r\n            id=\"btn\"\r\n            onClick={() => {stopExecution(); clearGrid();}}\r\n          >\r\n            CLEAR GRID\r\n          </button>\r\n          <button\r\n            className=\"button_slide slide_down\"\r\n            id=\"btn2\"\r\n            onClick={() => {stopExecution(); clearPath()}}\r\n          >\r\n            CLEAR PATH\r\n          </button>\r\n          <select\r\n            id=\"select_box\"\r\n            className=\"box slide_down\"\r\n            onChange={() => {\r\n              let value = document.getElementById(\"select_box\").value;\r\n              setDescription(descriptions[value]);\r\n              algo.current = value;\r\n            }}\r\n            defaultValue={0}\r\n          >\r\n            <option value={0}>ALGORITHM</option>\r\n            <option value={1}>DIJKSTRA</option>\r\n            <option value={2}>BREADTH FIRST</option>\r\n            <option value={3}>DEPTH FIRST</option>\r\n            <option value={4}>GREEDY</option>\r\n            <option value={5}>A STAR</option>\r\n          </select>\r\n          <button\r\n            className=\"button_slide slide_down\"\r\n            id=\"run_btn\"\r\n            onClick={playButtonLogic}\r\n          >\r\n            RUN\r\n          </button>\r\n        </div>\r\n        <div className=\"text\">{description}</div>\r\n        <div className=\"grid\" id='grid'>\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx} className=\"row\">\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall, weight } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      side={50}\r\n                      weight={weight}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) => handleMouseEnter(row, col)}\r\n                      onMouseUp={() => handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n          <div className=\"footer\"></div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n\r\nfunction resetNode(node, keepWall = false, keepWeights = false) {\r\n  node.distance = Infinity;\r\n  node.heuristic = Infinity;\r\n  node.isVisited = false;\r\n  node.previousNode = null;\r\n  if (!keepWall) node.isWall = false;\r\n  if (!keepWeights) node.weight = 1;\r\n}\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // Recreate the grid changing the wall property where needed\r\n  const node = grid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n    weight: 1,\r\n  };\r\n  grid[row][col] = newNode;\r\n  return grid;\r\n};\r\n\r\nconst getNewGridWithWeightToggled = (grid, row, col) => {\r\n  // Recreate the grid changing the weight property where needed\r\n  const node = grid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: false,\r\n    weight: node.weight === 15 ? 1 : 15,\r\n  };\r\n  grid[row][col] = newNode;\r\n  return grid;\r\n};\r\n\r\n// Function to generate random numbers from min to max, both inclusive\r\nfunction randomIntFromInterval(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathFindingVisualizer from './PathFindingVisualizer/PathFindingVisualizer'\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathFindingVisualizer></PathFindingVisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}