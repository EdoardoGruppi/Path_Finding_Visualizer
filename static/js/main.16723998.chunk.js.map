{"version":3,"sources":["PathFindingVisualizer/Node/Node.jsx","Algorithms/Utils.js","Algorithms/Dijkstra.js","Algorithms/BreadthFirst.js","Algorithms/DepthFirst.js","Algorithms/Greedy.js","Algorithms/AStar.js","PathFindingVisualizer/PathFindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","weight","isWall","side","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","style","height","width","className","Component","getUnvisitedNeighbors","node","grid","neighbors","length","push","filter","neighbor","isVisited","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","sortNodesByDistanceToEnd","heuristic","sortNodesByTotalDistance","getAllNodes","nodes","weightedHeuristic","additionalXChange","sumHorizontalWeights","otherXChange","additionalYChange","sumVerticalWeights","otherYChange","additionalChange","otherChange","weightedManhattanDistance","col1","col2","sum","currentCol","row1","row2","currentRow","dijkstra","startNode","finishNode","visitedNodesInOrder","closestNode","shift","Infinity","updateUnvisitedNeighbors","unvisitedNeighbors","previousNode","breadthFirst","queueNodesToVisit","depthFirst","unshift","greedy","distanceToEnd","aStar","PathfindingVisualizer","handleKeyDown","bind","state","rows","cols","speed","mouseIsPressed","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","itemPressed","keyPressed","description","getInitialGrid","document","addEventListener","setState","removeEventListener","createNode","newGrid","moveStartNode","moveFinishNode","getNewGridWithWeightToggled","getNewGridWithWallToggled","e","includes","key","newStartNode","newNode","newFinishNode","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","extraClass","getElementById","algorithm","dict","algorithmDescription","clearPath","currentNode","getNodesInShortestPathOrder","animateAlgorithm","resetNode","clearGrid","value","randomIntFromInterval","display","type","min","step","defaultValue","max","onChange","updateSpeed","updateGridSize","onClick","visualizeAlgorithm","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","keepWall","keepWeights","Math","floor","random","string","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.16723998.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      weight,\r\n      isWall,\r\n      side,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : weight > 1\r\n      ? \"node-weight\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        style={{\r\n          height: `${side}vh`,\r\n          width: `${side}vh`,\r\n        }}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","export function getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  // Get the neighbour at the right\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  // Get the neighbour at the top\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  // Get the neighbour at the bottom\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  // Get the neighbour at the left\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  // Return only the neighbours that have not been already visited\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// It must be called only AFTER the pathfinding algorithm.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    // Add the current node and pass to the previous node which is pointed by the current node\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function sortNodesByDistance(unvisitedNodes) {\r\n  // The sorting occurs following an ascending order\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function sortNodesByDistanceToEnd(unvisitedNodes) {\r\n  // The sorting occurs following an ascending order\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.heuristic - nodeB.heuristic);\r\n}\r\n\r\nexport function sortNodesByTotalDistance(unvisitedNodes) {\r\n  // The sorting occurs following an ascending order\r\n  unvisitedNodes.sort(\r\n    (nodeA, nodeB) =>\r\n      nodeA.heuristic + nodeA.distance - (nodeB.heuristic + nodeB.distance)\r\n  );\r\n}\r\n\r\nexport function getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function heuristic(nodeA, nodeB) {\r\n  // Heursitic function computed with the manhattan distance\r\n  return manhattanDistance(nodeA, nodeB);\r\n}\r\n\r\nfunction manhattanDistance(nodeA, nodeB) {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\nexport function weightedHeuristic(grid, nodeA, nodeB) {\r\n  // Heursitic function computed with a weighted version of the manhattan distance\r\n  return weightedManhattanDistance(grid, nodeA, nodeB);\r\n}\r\n\r\nfunction weightedManhattanDistance(grid, nodeA, nodeB) {\r\n  // To get the weighted manhattan distance, this function considers two distinct paths.\r\n  // The first pass through x1 to x2 and then from y1 to y2. The second viceversa.\r\n  const additionalXChange = sumHorizontalWeights(\r\n    grid,\r\n    nodeA.row,\r\n    nodeA.col,\r\n    nodeB.col\r\n  );\r\n  const otherXChange = sumHorizontalWeights(\r\n    grid,\r\n    nodeB.row,\r\n    nodeA.col,\r\n    nodeB.col\r\n  );\r\n  const additionalYChange = sumVerticalWeights(\r\n    grid,\r\n    nodeB.col,\r\n    nodeA.row,\r\n    nodeB.row\r\n  );\r\n  const otherYChange = sumVerticalWeights(\r\n    grid,\r\n    nodeA.col,\r\n    nodeA.row,\r\n    nodeB.row\r\n  );\r\n  const additionalChange = additionalXChange + additionalYChange;\r\n  const otherChange = otherXChange + otherYChange;\r\n  // Compare the two paths to return the one that is shortest\r\n  if (additionalChange < otherChange) return additionalChange;\r\n  else return otherChange;\r\n}\r\n\r\nfunction sumHorizontalWeights(grid, row, col1, col2) {\r\n  let sum = 0;\r\n  // Swap y1 and y2 if y1 > y2\r\n  if (col1 > col2) [col1, col2] = [col2, col1];\r\n  // Sum all the weights of the nodes in the path\r\n  for (let currentCol = col1; currentCol <= col2; currentCol++) {\r\n    const currentNode = grid[row][currentCol];\r\n    sum += currentNode.weight;\r\n  }\r\n  return sum;\r\n}\r\n\r\nfunction sumVerticalWeights(grid, col, row1, row2) {\r\n  let sum = 0;\r\n  // Swap x1 and x2 if x1 > x2. The '+1' and '-1' below are inserted to avoid\r\n  // considering twice the same node in the corner.\r\n  if (row1 > row2) [row1, row2] = [row2 + 1, row1];\r\n  else row2 = row2 - 1;\r\n  for (let currentRow = row1; currentRow <= row2; currentRow++) {\r\n    const currentNode = grid[currentRow][col];\r\n    sum += currentNode.weight;\r\n  }\r\n  return sum;\r\n}\r\n","import {\r\n  getUnvisitedNeighbors,\r\n  getAllNodes,\r\n  sortNodesByDistance,\r\n} from \"./Utils\";\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  // Except for the starting node the distance == Infinity\r\n  startNode.distance = 0;\r\n  // At the beginning all the nodes are unvisited\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  // While there are still unvisited nodes\r\n  while (unvisitedNodes.length) {\r\n    // Sort nodes by distance\r\n    sortNodesByDistance(unvisitedNodes);\r\n    // Take from the array the first element, i.e. the nearest\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity, the game is trapped and must be stopped\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    // Otherwise the node is traversed by the algorithm\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    // Update distances\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // The distance of the neighbours is equal to that of the node plus one\r\n    // So far, the algorithm version does not involve weights\r\n    // child distance = dist[currentNode from source] + distance [from currentNode to child node].\r\n    neighbor.distance = node.distance + neighbor.weight;\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n","import { getUnvisitedNeighbors } from \"./Utils\";\r\n\r\nexport function breadthFirst(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queueNodesToVisit = [];\r\n  startNode.isVisited = true;\r\n  queueNodesToVisit.push(startNode);\r\n  // While there are still unvisited nodes\r\n  while (queueNodesToVisit.length) {\r\n    const closestNode = queueNodesToVisit.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // Otherwise the node is traversed by the algorithm\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    queueNodesToVisit.push(...updateUnvisitedNeighbors(closestNode, grid));\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n    neighbor.isVisited = true;\r\n  }\r\n  return unvisitedNeighbors;\r\n}\r\n","import { getUnvisitedNeighbors } from \"./Utils\";\r\n\r\nexport function depthFirst(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queueNodesToVisit = [];\r\n  startNode.isVisited = true;\r\n  queueNodesToVisit.push(startNode);\r\n  // While there are still unvisited nodes\r\n  while (queueNodesToVisit.length) {\r\n    const closestNode = queueNodesToVisit.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // Otherwise the node is traversed by the algorithm\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    queueNodesToVisit.unshift(...updateUnvisitedNeighbors(closestNode, grid));\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n  }\r\n  return unvisitedNeighbors;\r\n}\r\n","import {\r\n  getUnvisitedNeighbors,\r\n  weightedHeuristic,\r\n  getAllNodes,\r\n  sortNodesByDistanceToEnd,\r\n} from \"./Utils\";\r\n\r\nexport function greedy(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  // Except for the starting node the distance == Infinity\r\n  startNode.heuristic = 0;\r\n  // At the beginning all the nodes are unvisited\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  // While there are still unvisited nodes\r\n  while (unvisitedNodes.length) {\r\n    // Sort nodes by distance\r\n    sortNodesByDistanceToEnd(unvisitedNodes);\r\n    // Take from the array the first element, i.e. the nearest\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity, the game is trapped and must be stopped\r\n    if (closestNode.heuristic === Infinity) return visitedNodesInOrder;\r\n    // Otherwise the node is traversed by the algorithm\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    // Update distances\r\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // The heuristic here used to compute the distance from the current node to the end is formulated\r\n    // as the sum between the weighted manhattan distance and the node weight.\r\n    const distanceToEnd =\r\n      neighbor.weight + weightedHeuristic(grid, neighbor, finishNode);\r\n    if (neighbor.heuristic > distanceToEnd) neighbor.heuristic = distanceToEnd;\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n","import {\r\n  getUnvisitedNeighbors,\r\n  weightedHeuristic,\r\n  getAllNodes,\r\n  sortNodesByTotalDistance,\r\n} from \"./Utils\";\r\n\r\nexport function aStar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  // Except for the starting node the distance == Infinity\r\n  startNode.distance = 0;\r\n  startNode.heuristic = weightedHeuristic(grid, startNode, finishNode);\r\n  // At the beginning all the nodes are unvisited\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  // While there are still unvisited nodes\r\n  while (unvisitedNodes.length) {\r\n    // Sort nodes by distance\r\n    sortNodesByTotalDistance(unvisitedNodes);\r\n    // Take from the array the first element, i.e. the nearest\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If it corresponds to a wall, it is skipped\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity, the game is trapped and must be stopped\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    // Otherwise the node is traversed by the algorithm\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    // If the node is the target the objective is accomplished\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    // Update distances\r\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // The distance is computed adding the node weight to the manhattan distance\r\n    const distance = node.distance + neighbor.weight;\r\n    if (neighbor.distance > distance) neighbor.distance = distance;\r\n    // On the other hand the heuristic is calculated as a weighted variant of the weighted manhattan distance\r\n    neighbor.heuristic = 1.5 * weightedHeuristic(grid, neighbor, finishNode);\r\n    // Link each neighbour to the previous node\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathFindingVisualizer.css\";\r\nimport { dijkstra } from \"../Algorithms/Dijkstra\";\r\nimport { breadthFirst } from \"../Algorithms/BreadthFirst\";\r\nimport { depthFirst } from \"../Algorithms/DepthFirst\";\r\nimport { greedy } from \"../Algorithms/Greedy\";\r\nimport { aStar } from \"../Algorithms/AStar\";\r\nimport { getNodesInShortestPathOrder } from \"../Algorithms/Utils\";\r\nimport \"../Design/Button.css\";\r\nimport \"../Design/SelectBox.css\";\r\nimport \"../Design/Slider.css\";\r\nimport \"../Design/Header.css\";\r\nimport \"../Design/Text.css\";\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.handleKeyDown = this.handleKeyDown.bind(this);\r\n    this.state = {\r\n      grid: [],\r\n      rows: 20,\r\n      cols: 52,\r\n      speed: 10,\r\n      // Element that follows the mouse events\r\n      mouseIsPressed: false,\r\n      // Rows and Cols of the starting and final node\r\n      startNodeRow: 10,\r\n      startNodeCol: 15,\r\n      finishNodeRow: 10,\r\n      finishNodeCol: 35,\r\n      // Element to keep track whether a special node is pressed\r\n      itemPressed: null,\r\n      // Element to know which key has been pressed\r\n      keyPressed: \"r\",\r\n      description: \"Press W to insert weights and R to get back to walls.\",\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    // Add a listener to react when a key is pressed\r\n    document.addEventListener(\"keydown\", this.handleKeyDown);\r\n    this.setState({ grid: grid });\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\r\n  }\r\n\r\n  createNode(col, row) {\r\n    // Create a node with the default values\r\n    return {\r\n      col,\r\n      row,\r\n      isStart:\r\n        row === this.state.startNodeRow && col === this.state.startNodeCol,\r\n      isFinish:\r\n        row === this.state.finishNodeRow && col === this.state.finishNodeCol,\r\n      // Distance from the starting Node\r\n      distance: Infinity,\r\n      // Distance from the end node computed with heuristic\r\n      heuristic: Infinity,\r\n      weight: 1,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n    };\r\n  }\r\n\r\n  getInitialGrid() {\r\n    // Create a 2d Array of new nodes\r\n    const grid = [];\r\n    for (let row = 0; row < this.state.rows; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < this.state.cols; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    // Function called when the mouse is pressed down\r\n    const node = this.state.grid[row][col];\r\n    let itemPressed = null;\r\n    let newGrid = [];\r\n    if (node.isStart) {\r\n      newGrid = this.moveStartNode(this.state.grid, row, col);\r\n      itemPressed = \"startNode\";\r\n    } else if (node.isFinish) {\r\n      newGrid = this.moveFinishNode(this.state.grid, row, col);\r\n      itemPressed = \"finishNode\";\r\n    } else if (this.state.keyPressed === \"w\") {\r\n      newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\r\n    } else {\r\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    }\r\n    this.setState({\r\n      grid: newGrid,\r\n      mouseIsPressed: true,\r\n      itemPressed: itemPressed,\r\n    });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    // Change the nodes wall status if the mouse is moved after being pressed down\r\n    if (!this.state.mouseIsPressed) return;\r\n    let newGrid = [];\r\n    if (this.state.itemPressed === \"startNode\") {\r\n      newGrid = this.moveStartNode(this.state.grid, row, col);\r\n    } else if (this.state.itemPressed === \"finishNode\") {\r\n      newGrid = this.moveFinishNode(this.state.grid, row, col);\r\n    } else if (this.state.keyPressed === \"w\") {\r\n      newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\r\n    } else {\r\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    }\r\n\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    // Function called when the mouse is pressed up\r\n    this.setState({ mouseIsPressed: false, itemPressed: null });\r\n  }\r\n\r\n  handleKeyDown(e) {\r\n    // Keep track of the jey pressed only if it corresponds to r or w\r\n    if (\"rw\".includes(e.key)) this.setState({ keyPressed: e.key });\r\n  }\r\n\r\n  moveStartNode(grid, row, col) {\r\n    const { startNodeRow, startNodeCol } = this.state;\r\n    const previousStartNode = grid[startNodeRow][startNodeCol];\r\n    previousStartNode.isStart = false;\r\n    const newStartNode = grid[row][col];\r\n    const newNode = {\r\n      ...newStartNode,\r\n      isStart: true,\r\n    };\r\n    grid[row][col] = newNode;\r\n    this.setState({ startNodeRow: row, startNodeCol: col });\r\n    return grid;\r\n  }\r\n\r\n  moveFinishNode(grid, row, col) {\r\n    const { finishNodeRow, finishNodeCol } = this.state;\r\n    const previousFinishNode = grid[finishNodeRow][finishNodeCol];\r\n    previousFinishNode.isFinish = false;\r\n    const newFinishNode = grid[row][col];\r\n    const newNode = {\r\n      ...newFinishNode,\r\n      isFinish: true,\r\n    };\r\n    grid[row][col] = newNode;\r\n    this.setState({ finishNodeRow: row, finishNodeCol: col });\r\n    return grid;\r\n  }\r\n\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    // For each visited node\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      // Only if it is the last node start the final animation\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, this.state.speed * i);\r\n        return;\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n          let extraClass = \"\";\r\n          if (node.isStart) extraClass = \"start-\";\r\n          else if (node.isFinish) extraClass = \"finish-\";\r\n          else if (node.weight > 1) extraClass = \"weight-\";\r\n          // Animate the node according to its characteristics\r\n          document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          ).className = `node ${extraClass}node-visited`;\r\n        }, this.state.speed * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    // Animation showing the shortest path\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        let extraClass = \"\";\r\n        if (node.isStart) extraClass = \"start-\";\r\n        else if (node.isFinish) extraClass = \"finish-\";\r\n        else if (node.weight > 1) extraClass = \"weight-\";\r\n        // Animate the node according to its characteristics\r\n        document.getElementById(\r\n          `node-${node.row}-${node.col}`\r\n        ).className = `node ${extraClass}node-shortest-path`;\r\n      }, this.state.speed * 5 * i);\r\n    }\r\n  }\r\n\r\n  visualizeAlgorithm(algorithm) {\r\n    const dict = {\r\n      dijkstra: dijkstra,\r\n      breadthFirst: breadthFirst,\r\n      depthFirst: depthFirst,\r\n      greedy: greedy,\r\n      aStar: aStar,\r\n    };\r\n    // Update algorithm description\r\n    this.setState({ description: algorithmDescription(algorithm) });\r\n    // Clean the board from the previous path\r\n    this.clearPath();\r\n    const { grid, startNodeRow, startNodeCol, finishNodeRow, finishNodeCol } =\r\n      this.state;\r\n    // Set up the starting and final nodes\r\n    const startNode = grid[startNodeRow][startNodeCol];\r\n    const finishNode = grid[finishNodeRow][finishNodeCol];\r\n    // Get the visited nodes in order\r\n    const visitedNodesInOrder = dict[algorithm](grid, startNode, finishNode);\r\n    // Get the nodes, belonging to the shortest path and visisted in order\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  clearGrid() {\r\n    const { grid } = this.state;\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        // Reset the features of the node\r\n        resetNode(node);\r\n        const extraClassName = node.isFinish\r\n          ? \"node-finish\"\r\n          : node.isStart\r\n          ? \"node-start\"\r\n          : node.isWall\r\n          ? \"node-wall\"\r\n          : \"\";\r\n        // Update the node visualization\r\n        document.getElementById(\r\n          `node-${node.row}-${node.col}`\r\n        ).className = `node ${extraClassName}`;\r\n      }\r\n    }\r\n  }\r\n\r\n  clearPath() {\r\n    const { grid } = this.state;\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        // Reset each node but retain the wall and the weighted cells\r\n        resetNode(node, true, true);\r\n        const extraClassName = node.isFinish\r\n          ? \"node-finish\"\r\n          : node.isStart\r\n          ? \"node-start\"\r\n          : node.isWall\r\n          ? \"node-wall\"\r\n          : node.weight > 1\r\n          ? \"node-weight\"\r\n          : \"\";\r\n        // Update the node visualization\r\n        document.getElementById(\r\n          `node-${node.row}-${node.col}`\r\n        ).className = `node ${extraClassName}`;\r\n      }\r\n    }\r\n  }\r\n\r\n  updateGridSize() {\r\n    // Clear the entire grid\r\n    this.clearGrid();\r\n    // Get the new row values selected through the slider\r\n    const rows = document.getElementById(\"n_rows\").value;\r\n    const cols = rows * 2.6;\r\n    this.setState(\r\n      {\r\n        rows: rows,\r\n        cols: cols,\r\n        // Randomly set the position of the starting and final nodes\r\n        startNodeRow: randomIntFromInterval(0, rows - 1),\r\n        startNodeCol: randomIntFromInterval(0, cols / 2),\r\n        finishNodeRow: randomIntFromInterval(0, rows - 1),\r\n        finishNodeCol: randomIntFromInterval(cols / 2 + 1, cols - 1),\r\n      },\r\n      () => {\r\n        const grid = this.getInitialGrid();\r\n        this.setState({ grid: grid });\r\n      }\r\n    );\r\n  }\r\n\r\n  updateSpeed() {\r\n    // Update the animation speed as expressed by means of the slider\r\n    const speed = document.getElementById(\"speed\").value;\r\n    this.setState({ speed: speed }, () => {});\r\n  }\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    // Get the size of each cell\r\n    const side = 65 / this.state.rows;\r\n\r\n    return (\r\n      <>\r\n        <div className=\"header\">\r\n          <div style={{ display: \"inline-block\" }}>\r\n            <span className=\"rangeValue\">SPEED: {this.state.speed}</span>\r\n            <input\r\n              className=\"range\"\r\n              id=\"speed\"\r\n              type=\"range\"\r\n              min=\"1\"\r\n              step=\"1\"\r\n              defaultValue=\"10\"\r\n              max=\"1000\"\r\n              onChange={() => this.updateSpeed()}\r\n            ></input>\r\n          </div>\r\n          <div style={{ display: \"inline-block\" }}>\r\n            <span className=\"rangeValue\">ROWS: {this.state.rows}</span>\r\n            <input\r\n              className=\"range\"\r\n              id=\"n_rows\"\r\n              type=\"range\"\r\n              min=\"5\"\r\n              step=\"1\"\r\n              defaultValue=\"20\"\r\n              max=\"23\"\r\n              onChange={() => this.updateGridSize()}\r\n            ></input>\r\n          </div>\r\n          <button\r\n            className=\"button_slide slide_down\"\r\n            id=\"btn\"\r\n            onClick={() => this.clearGrid()}\r\n          >\r\n            CLEAR GRID\r\n          </button>\r\n          <button\r\n            className=\"button_slide slide_down\"\r\n            id=\"btn2\"\r\n            onClick={() => this.clearPath()}\r\n          >\r\n            CLEAR PATH\r\n          </button>\r\n          <select\r\n            id=\"select_box\"\r\n            className=\"box slide_down\"\r\n            onChange={() => {\r\n              let value = document.getElementById(\"select_box\").value;\r\n              if (value !== \"default\") this.visualizeAlgorithm(value);\r\n              else\r\n                this.setState({\r\n                  description:\r\n                    \"Press W to insert weights and R to get back to walls.\",\r\n                });\r\n            }}\r\n            defaultValue=\"default\"\r\n          >\r\n            <option value=\"default\">ALGORITHM</option>\r\n            <option value=\"dijkstra\">DIJKSTRA</option>\r\n            <option value=\"breadthFirst\">BREADTH FIRST</option>\r\n            <option value=\"depthFirst\">DEPTH FIRST</option>\r\n            <option value=\"greedy\">GREEDY</option>\r\n            <option value=\"aStar\">A STAR</option>\r\n          </select>\r\n        </div>\r\n        <div className=\"text\">{this.state.description}</div>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall, weight } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      side={side}\r\n                      weight={weight}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nfunction resetNode(node, keepWall = false, keepWeights = false) {\r\n  node.distance = Infinity;\r\n  node.heuristic = Infinity;\r\n  node.isVisited = false;\r\n  node.previousNode = null;\r\n  if (!keepWall) node.isWall = false;\r\n  if (!keepWeights) node.weight = 1;\r\n}\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // Recreate the grid changing the wall property where needed\r\n  const node = grid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n    weight: 1,\r\n  };\r\n  grid[row][col] = newNode;\r\n  return grid;\r\n};\r\n\r\nconst getNewGridWithWeightToggled = (grid, row, col) => {\r\n  // Recreate the grid changing the weight property where needed\r\n  const node = grid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: false,\r\n    weight: node.weight === 15 ? 1 : 15,\r\n  };\r\n  grid[row][col] = newNode;\r\n  return grid;\r\n};\r\n\r\n// Function to generate random numbers from min to max, both inclusive\r\nfunction randomIntFromInterval(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nfunction algorithmDescription(string) {\r\n  const dict = {\r\n    dijkstra:\r\n      \"Dijkstra is a weighted algorithm that guarantees the shortest possible path.\",\r\n    breadthFirst:\r\n      \"BreadthFirst is an unweighted algorithm that guarantees the shortest possible path.\",\r\n    depthFirst:\r\n      \"DepthFirst is an unweighted algorithm that does not guarantee the shortest path.\",\r\n    greedy:\r\n      \"Greedy is a weighted algorithm that does not guarantee the shortest path.\",\r\n    aStar:\r\n      \"A* is a weighted algorithm that usually guarantees the shortest possible path.\",\r\n  };\r\n  return dict[string];\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathFindingVisualizer from './PathFindingVisualizer/PathFindingVisualizer'\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathFindingVisualizer></PathFindingVisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}